<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Tutorial &mdash; Charliecloud 0.29 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Charliecloud command reference" href="command-usage.html" />
    <link rel="prev" title="1. Installing" href="install.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Charliecloud
            <img src="_static/logo-sidebar.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.29
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">1. Installing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#seconds-to-charliecloud">2.1. 90 seconds to Charliecloud</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-help">2.2. Getting help</a></li>
<li class="toctree-l2"><a class="reference internal" href="#your-first-user-defined-software-stack">2.3. Your first user-defined software stack</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#defining-your-udss">2.3.1. Defining your UDSS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-charliecloud-image">2.3.2. Build Charliecloud image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sharing-images">2.3.3. Sharing images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributing-images">2.3.4. Distributing images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-images">2.3.5. Running images</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interacting-with-the-host">2.4. Interacting with the host</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#filesystems">2.4.1. Filesystems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network">2.4.2. Network</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-and-group-ids">2.4.3. User and group IDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#installing-your-own-software">2.5. Installing your own software</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#third-party-software-via-package-manager">2.5.1. Third-party software via package manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#third-party-software-compiled-from-source">2.5.2. Third-party software compiled from source</a></li>
<li class="toctree-l3"><a class="reference internal" href="#your-software-stored-in-the-image">2.5.3. Your software stored in the image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#your-software-stored-on-the-host">2.5.4. Your software stored on the host</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#your-first-single-node-multi-process-jobs">2.6. Your first single-node, multi-process jobs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#processes-coordinated-by-host">2.6.1. Processes coordinated by host</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processes-coordinated-by-container">2.6.2. Processes coordinated by container</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#your-first-multi-node-jobs">2.7. Your first multi-node jobs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interactive-mpi-hello-world">2.7.1. Interactive MPI hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-interactive-mpi-hello-world">2.7.2. Non-interactive MPI hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interactive-apache-spark">2.7.3. Interactive Apache Spark</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-interactive-apache-spark">2.7.4. Non-interactive Apache Spark</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="command-usage.html">3. Charliecloud command reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">4. Frequently asked questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html">5. Contributor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Charliecloud</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">2. </span>Tutorial</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial">
<h1><span class="section-number">2. </span>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will teach you how to create and run Charliecloud images, using
both examples included with the source code as well as new ones you create
from scratch.</p>
<p>This tutorial assumes that: (a) Charliecloud is in your path, including
Charliecloud’s fully unprivileged image builder <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> and (b) the
Charliecloud source code is available at <code class="code docutils literal notranslate"><span class="pre">/usr/local/src/charliecloud</span></code>.
Optionally, (c) <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> is linked with SquashFUSE to provide internal
SquashFS image mounting. (If you wish to use Docker to build images, see the
<a class="reference internal" href="faq.html#faq-building-with-docker"><span class="std std-ref">FAQ</span></a>.)</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#seconds-to-charliecloud" id="id1">90 seconds to Charliecloud</a></p></li>
<li><p><a class="reference internal" href="#getting-help" id="id2">Getting help</a></p></li>
<li><p><a class="reference internal" href="#your-first-user-defined-software-stack" id="id3">Your first user-defined software stack</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-your-udss" id="id4">Defining your UDSS</a></p></li>
<li><p><a class="reference internal" href="#build-charliecloud-image" id="id5">Build Charliecloud image</a></p></li>
<li><p><a class="reference internal" href="#sharing-images" id="id6">Sharing images</a></p></li>
<li><p><a class="reference internal" href="#distributing-images" id="id7">Distributing images</a></p></li>
<li><p><a class="reference internal" href="#running-images" id="id8">Running images</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#interacting-with-the-host" id="id9">Interacting with the host</a></p>
<ul>
<li><p><a class="reference internal" href="#filesystems" id="id10">Filesystems</a></p></li>
<li><p><a class="reference internal" href="#network" id="id11">Network</a></p></li>
<li><p><a class="reference internal" href="#user-and-group-ids" id="id12">User and group IDs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#installing-your-own-software" id="id13">Installing your own software</a></p>
<ul>
<li><p><a class="reference internal" href="#third-party-software-via-package-manager" id="id14">Third-party software via package manager</a></p></li>
<li><p><a class="reference internal" href="#third-party-software-compiled-from-source" id="id15">Third-party software compiled from source</a></p></li>
<li><p><a class="reference internal" href="#your-software-stored-in-the-image" id="id16">Your software stored in the image</a></p></li>
<li><p><a class="reference internal" href="#your-software-stored-on-the-host" id="id17">Your software stored on the host</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#your-first-single-node-multi-process-jobs" id="id18">Your first single-node, multi-process jobs</a></p>
<ul>
<li><p><a class="reference internal" href="#processes-coordinated-by-host" id="id19">Processes coordinated by host</a></p></li>
<li><p><a class="reference internal" href="#processes-coordinated-by-container" id="id20">Processes coordinated by container</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#your-first-multi-node-jobs" id="id21">Your first multi-node jobs</a></p>
<ul>
<li><p><a class="reference internal" href="#interactive-mpi-hello-world" id="id22">Interactive MPI hello world</a></p></li>
<li><p><a class="reference internal" href="#non-interactive-mpi-hello-world" id="id23">Non-interactive MPI hello world</a></p></li>
<li><p><a class="reference internal" href="#interactive-apache-spark" id="id24">Interactive Apache Spark</a></p></li>
<li><p><a class="reference internal" href="#non-interactive-apache-spark" id="id25">Non-interactive Apache Spark</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shell sessions throughout this documentation will use the prompt <code class="code docutils literal notranslate"><span class="pre">$</span></code>
to indicate commands executed natively on the host and <code class="code docutils literal notranslate"><span class="pre">&gt;</span></code> for
commands executed in a container.</p>
</div>
<section id="seconds-to-charliecloud">
<h2><a class="toc-backref" href="#id1"><span class="section-number">2.1. </span>90 seconds to Charliecloud</a><a class="headerlink" href="#seconds-to-charliecloud" title="Permalink to this headline">¶</a></h2>
<p>This section is for the impatient. It shows you how to quickly build and run a
“hello world” Charliecloud container. If you like what you see, then proceed
with the rest of the tutorial to understand what is happening and how to use
Charliecloud for your own applications.</p>
<p>The preferred workflow uses our internal SquashFS mounting code. Your sysadmin
should be able to tell you if this is linked in.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> /usr/local/share/doc/charliecloud/examples/hello
<span class="gp">$</span> ch-image build --force .
<span class="go">inferred image name: hello</span>
<span class="go">[...]</span>
<span class="go">grown in 4 instructions: hello</span>
<span class="gp">$</span> ch-convert hello /var/tmp/hello.sqfs
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  squash    /var/tmp/hello.sqfs</span>
<span class="go">packing ...</span>
<span class="go">Parallel mksquashfs: Using 8 processors</span>
<span class="go">Creating 4.0 filesystem on /var/tmp/hello.sqfs, block size 65536.</span>
<span class="go">[=============================================|] 10411/10411 100%</span>
<span class="go">[...]</span>
<span class="go">done</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- <span class="nb">echo</span> <span class="s2">&quot;I&#39;m in a container&quot;</span>
<span class="go">I&#39;m in a container</span>
</pre></div>
</div>
<p>If not, you can create image in plain directory format instead:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> /usr/local/share/doc/charliecloud/examples/hello
<span class="gp">$</span> ch-image build --force .
<span class="go">inferred image name: hello</span>
<span class="go">[...]</span>
<span class="go">grown in 4 instructions: hello</span>
<span class="gp">$</span> ch-convert hello /var/tmp/hello
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  dir       /var/tmp/hello</span>
<span class="go">exporting ...</span>
<span class="go">done</span>
<span class="gp">$</span> ch-run /var/tmp/hello -- <span class="nb">echo</span> <span class="s2">&quot;I&#39;m in a container&quot;</span>
<span class="go">I&#39;m in a container</span>
</pre></div>
</div>
</section>
<section id="getting-help">
<h2><a class="toc-backref" href="#id2"><span class="section-number">2.2. </span>Getting help</a><a class="headerlink" href="#getting-help" title="Permalink to this headline">¶</a></h2>
<p>All the executables have decent help and can tell you what version of
Charliecloud you have (if not, please report a bug). For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --help
<span class="go">Usage: ch-run [OPTION...] NEWROOT CMD [ARG...]</span>

<span class="go">Run a command in a Charliecloud container.</span>
<span class="go">[...]</span>
<span class="gp">$</span> ch-run --version
<span class="go">0.26</span>
</pre></div>
</div>
<p>A description of all commands is also collected later in this documentation; see
<a class="reference internal" href="command-usage.html"><span class="doc">Charliecloud command reference</span></a>. In addition, each executable has a man page.</p>
</section>
<section id="your-first-user-defined-software-stack">
<h2><a class="toc-backref" href="#id3"><span class="section-number">2.3. </span>Your first user-defined software stack</a><a class="headerlink" href="#your-first-user-defined-software-stack" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will create and run a simple “hello, world” image. This
uses the <code class="code docutils literal notranslate"><span class="pre">hello</span></code> example in the Charliecloud source code. Start with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> examples/hello
</pre></div>
</div>
<section id="defining-your-udss">
<h3><a class="toc-backref" href="#id4"><span class="section-number">2.3.1. </span>Defining your UDSS</a><a class="headerlink" href="#defining-your-udss" title="Permalink to this headline">¶</a></h3>
<p>You must first write a Dockerfile that describes the image you would like;
consult the <a class="reference external" href="https://docs.docker.com/engine/reference/builder/">Dockerfile documentation</a> for details on how to do
this. Note that run-time functionality such as <code class="code docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> is not
supported.</p>
<p>We will use the following simple Dockerfile:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># ch-test-scope: standard</span>
<span class="k">FROM</span> <span class="s">almalinux:8</span>

<span class="k">RUN</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> openssh-clients <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf clean all

<span class="k">COPY</span> . hello

<span class="k">RUN</span> touch /usr/bin/ch-ssh
</pre></div>
</div>
<p>This creates a minimal AlmaLinux 8 image with <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> installed. We
will encounter more complex Dockerfiles later in this tutorial.</p>
</section>
<section id="build-charliecloud-image">
<h3><a class="toc-backref" href="#id5"><span class="section-number">2.3.2. </span>Build Charliecloud image</a><a class="headerlink" href="#build-charliecloud-image" title="Permalink to this headline">¶</a></h3>
<p>The three arguments here are the <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> subcommand <code class="code docutils literal notranslate"><span class="pre">build</span></code>,
the option to enable unprivileged build workarounds <code class="code docutils literal notranslate"><span class="pre">--force</span></code>, and the
context directory <code class="code docutils literal notranslate"><span class="pre">.</span></code>, which in this case is the current directory.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build --force .
<span class="go">inferred image name: hello</span>
<span class="go">2 FROM almalinux:8</span>
<span class="go">will use --force: rhel8: CentOS/RHEL 8+</span>
<span class="go">[...]</span>
<span class="go">7 COPY [&#39;.&#39;] -&gt; &#39;hello&#39;</span>
<span class="go">9 RUN [&#39;/bin/sh&#39;, &#39;-c&#39;, &#39;touch /usr/bin/ch-ssh&#39;]</span>
<span class="go">--force: init OK &amp; modified 1 RUN instructions</span>
<span class="go">grown in 4 instructions: hello</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> prints information about the build process while in
progress. While not shown above, it uses yellow for this chatter, while
build command output remains in the default color (e.g., white).</p>
</div>
<p>This image and the <code class="code docutils literal notranslate"><span class="pre">almalinux:8</span></code> base image used to build it are now
visible in Charliecloud’s builder storage:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image list
<span class="go">almalinux:8</span>
<span class="go">hello</span>
</pre></div>
</div>
</section>
<section id="sharing-images">
<h3><a class="toc-backref" href="#id6"><span class="section-number">2.3.3. </span>Sharing images</a><a class="headerlink" href="#sharing-images" title="Permalink to this headline">¶</a></h3>
<p>Charliecloud images in internal storage can be converted to multiple formats
via <code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code>, e.g. SquashFS (if SquashFUSE is installed):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert hello /var/tmp/hello.sqfs
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  squash    /var/tmp/hello.sqfs</span>
<span class="go">packing ...</span>
<span class="go">[...]</span>
<span class="go">done</span>
<span class="gp">$</span> ls -l /var/tmp/hello.sqfs
<span class="go">-rw-rw-r-- 1 heasterday heasterday 83288064 Nov 15 12:07 /var/tmp/hello.sqfs</span>
</pre></div>
</div>
<p>Tarball:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert hello /var/tmp/hello.tar.gz
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  tar       /var/tmp/hello.tar.gz</span>
<span class="go">exporting ...</span>
<span class="go">done</span>
<span class="gp">$</span> ls -l /var/tmp/hello.tar.gz
<span class="go">-rw-rw-r-- 1 heasterday heasterday 86122450 Nov 15 15:23 /var/tmp/hello.tar.gz</span>
</pre></div>
</div>
<p>Directory:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert hello /var/tmp/hello
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  dir       /var/tmp/hello</span>
<span class="go">exporting ...</span>
<span class="go">done</span>
<span class="gp">$</span> ls /var/tmp/hello
<span class="go">bin  dev  hello  lib    lost+found  mnt  proc  run   srv  tmp  var</span>
<span class="go">ch   etc  home   lib64  media       opt  root  sbin  sys  usr</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code> can also convert images between any two supported formats,
e.g. SquashFS to tarball:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert hello.sqfs hello.tar.gz
<span class="go">input:   tar       hello.tar.gz</span>
<span class="go">output:  squash    hello.sqfs</span>
<span class="go">unpacking ...</span>
<span class="go">[...]</span>
<span class="go">done</span>
</pre></div>
</div>
<p>Tarball to directory:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert /var/tmp/hello.tar.gz /var/tmp/hello
<span class="go">input:   tar       /var/tmp/hello.tar.gz</span>
<span class="go">output:  dir       /var/tmp/hello</span>
<span class="go">unpacking ...</span>
<span class="go">[...]</span>
<span class="go">done</span>
</pre></div>
</div>
<p>Charliecloud also supports “pushing” images from its internal storage to a
registry using <code class="code docutils literal notranslate"><span class="pre">ch-image</span> <span class="pre">push</span></code> and “pulling” images in the reverse
direction with <code class="code docutils literal notranslate"><span class="pre">ch-image</span> <span class="pre">pull</span></code>.</p>
</section>
<section id="distributing-images">
<h3><a class="toc-backref" href="#id7"><span class="section-number">2.3.4. </span>Distributing images</a><a class="headerlink" href="#distributing-images" title="Permalink to this headline">¶</a></h3>
<p>Thus far, the workflow has taken place on the build system. The next step is
to copy the built image to the run system. This can use any appropriate method
for moving files: <code class="code docutils literal notranslate"><span class="pre">scp</span></code>, <code class="code docutils literal notranslate"><span class="pre">rsync</span></code>, something integrated with the
scheduler, etc. (The purpose of the tarball image format is to put images in a
single file that’s easy to move around with traditional UNIX commands.)</p>
<p>If the build and run systems are the same, then no copy is needed. This is a
typical use case for development and testing.</p>
<p>If you are using the SquashFS workflow, copy the <code class="code docutils literal notranslate"><span class="pre">.sqfs</span></code> file you
created above to the run system; otherwise, copy the <code class="code docutils literal notranslate"><span class="pre">.tar.gz</span></code>, then
unpack it on the run system using <code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code> as above.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Generally, you should avoid directory-format images on shared filesystems
such as NFS and Lustre, in favor of local storage such as <code class="code docutils literal notranslate"><span class="pre">tmpfs</span></code> and
local hard disks. This will yield better performance for you and anyone
else on the shared filesystem. In contrast, SquashFS images should work
fine on shared filesystems.</p>
</div>
</section>
<section id="running-images">
<h3><a class="toc-backref" href="#id8"><span class="section-number">2.3.5. </span>Running images</a><a class="headerlink" href="#running-images" title="Permalink to this headline">¶</a></h3>
<p>We are now ready to run programs inside a Charliecloud container. This is done
with the <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- <span class="nb">echo</span> hello
<span class="go">hello</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run /var/tmp/hello -- <span class="nb">echo</span> hello
<span class="go">hello</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can run perfectly well out of <code class="code docutils literal notranslate"><span class="pre">/tmp</span></code>, but because it is
bind-mounted automatically, the image root will then appear in multiple
locations in the container’s filesystem tree. This can cause confusion for
both users and programs.</p>
</div>
<p>Symbolic links in <code class="code docutils literal notranslate"><span class="pre">/proc</span></code> tell us the current namespaces, which are
identified by long ID numbers:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /proc/self/ns
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 ipc -&gt; ipc:[4026531839]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 mnt -&gt; mnt:[4026531840]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 net -&gt; net:[4026531969]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 pid -&gt; pid:[4026531836]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 user -&gt; user:[4026531837]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 11:24 uts -&gt; uts:[4026531838]</span>
<span class="gp">$</span> ch-run /var/tmp/hello -- ls -l /proc/self/ns
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 ipc -&gt; ipc:[4026531839]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 mnt -&gt; mnt:[4026532257]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 net -&gt; net:[4026531969]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 pid -&gt; pid:[4026531836]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 user -&gt; user:[4026532256]</span>
<span class="go">lrwxrwxrwx 1 reidpr reidpr 0 Sep 28 17:34 uts -&gt; uts:[4026531838]</span>
</pre></div>
</div>
<p>Notice that the container has different mount (<code class="code docutils literal notranslate"><span class="pre">mnt</span></code>) and user
(<code class="code docutils literal notranslate"><span class="pre">user</span></code>) namespaces, but the rest of the namespaces are shared with the
host. This highlights Charliecloud’s focus on functionality (make your UDSS
run), rather than isolation (protect the host from your UDSS).</p>
<p>Normally, each invocation of <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> creates a new container, so if you
have multiple simultaneous invocations, they will not share containers. In
some cases this can cause problems with MPI programs. However, there is an
option <code class="code docutils literal notranslate"><span class="pre">--join</span></code> that can solve them; see the <a class="reference internal" href="faq.html#faq-join"><span class="std std-ref">FAQ</span></a> for
details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">--</span></code> in the <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> command line is a standard argument
that separates options from non-option arguments. Without it,
<code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> would try (and fail) to interpret <code class="code docutils literal notranslate"><span class="pre">ls</span></code>’s <code class="code docutils literal notranslate"><span class="pre">-l</span></code>
argument.</p>
</div>
<p>These IDs are available both in the symlink target as well as its inode
number:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ch-run /var/tmp/hello -- stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
</pre></div>
</div>
<p>You can also run interactive commands, such as a shell:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- /bin/bash
<span class="gp">&gt;</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>Be aware that wildcards in the <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> command are interpreted by the
host, not the container, unless protected. One workaround is to use a
sub-shell. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /usr/bin/oldfind
<span class="go">ls: cannot access &#39;/usr/bin/oldfind&#39;: No such file or directory</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- ls /usr/bin/oldfind
<span class="go">/usr/bin/oldfind</span>
<span class="gp">$</span> ls /usr/bin/oldf*
<span class="go">ls: cannot access &#39;/usr/bin/oldf*&#39;: No such file or directory</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- ls /usr/bin/oldf*
<span class="go">ls: cannot access /usr/bin/oldf*: No such file or directory</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- sh -c <span class="s1">&#39;ls /usr/bin/oldf*&#39;</span>
<span class="go">/usr/bin/oldfind</span>
</pre></div>
</div>
<p>You have now successfully run commands within a single-node Charliecloud
container. Next, we explore how Charliecloud accesses host resources.</p>
</section>
</section>
<section id="interacting-with-the-host">
<h2><a class="toc-backref" href="#id9"><span class="section-number">2.4. </span>Interacting with the host</a><a class="headerlink" href="#interacting-with-the-host" title="Permalink to this headline">¶</a></h2>
<p>Charliecloud is not an isolation layer, so containers have full access to host
resources, with a few quirks. This section demonstrates how this works.</p>
<section id="filesystems">
<h3><a class="toc-backref" href="#id10"><span class="section-number">2.4.1. </span>Filesystems</a><a class="headerlink" href="#filesystems" title="Permalink to this headline">¶</a></h3>
<p>Charliecloud makes host directories available inside the container using bind
mounts, which is somewhat like a hard link in that it causes a file or
directory to appear in multiple places in the filesystem tree, but it is a
property of the running kernel rather than the filesystem.</p>
<p>Several host directories are always bind-mounted into the container. These
include system directories such as <code class="code docutils literal notranslate"><span class="pre">/dev</span></code>, <code class="code docutils literal notranslate"><span class="pre">/proc</span></code>, and
<code class="code docutils literal notranslate"><span class="pre">/sys</span></code>; <code class="code docutils literal notranslate"><span class="pre">/tmp</span></code>; Charliecloud’s <code class="code docutils literal notranslate"><span class="pre">ch-ssh</span></code> command in
<code class="code docutils literal notranslate"><span class="pre">/usr/bin</span></code>; and the invoking user’s home directory (for dotfiles),
unless <code class="code docutils literal notranslate"><span class="pre">--no-home</span></code> is specified.</p>
<p>Charliecloud uses recursive bind mounts, so for example if the host has a
variety of sub-filesystems under <code class="code docutils literal notranslate"><span class="pre">/sys</span></code>, as Ubuntu does, these will be
available in the container as well.</p>
<p>In addition to the default bind mounts, arbitrary user-specified directories
can be added using the <code class="code docutils literal notranslate"><span class="pre">--bind</span></code> or <code class="code docutils literal notranslate"><span class="pre">-b</span></code> switch. By default, mounts
use the same path as provided from the host. In the case of directory images,
which are writeable, the target mount directory will be automatically created
before the container is started:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /var/tmp/foo0
<span class="gp">$</span> <span class="nb">echo</span> hello &gt; /var/tmp/foo0/bar
<span class="gp">$</span> mkdir /var/tmp/foo1
<span class="gp">$</span> <span class="nb">echo</span> world &gt; /var/tmp/foo1/bar
<span class="gp">$</span> ch-run -b /var/tmp/foo0 -b /var/tmp/foo1 /var/tmp/hello -- bash
<span class="gp">&gt;</span> cat /var/tmp/foo0/bar
<span class="go">hello</span>
<span class="gp">&gt;</span> cat /var/tmp/foo1/bar
<span class="go">world</span>
</pre></div>
</div>
<p>However, as SquashFS filesystems are read-only, in this case you must provide
a destination that already exists, like those created under <code class="code docutils literal notranslate"><span class="pre">/mnt</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /var/tmp/foo0
<span class="gp">$</span> <span class="nb">echo</span> hello &gt; /var/tmp/foo0/bar
<span class="gp">$</span> mkdir /var/tmp/foo1
<span class="gp">$</span> <span class="nb">echo</span> world &gt; /var/tmp/foo1/bar
<span class="gp">$</span> ch-run -b /var/tmp/foo0 -b /var/tmp/foo1 /var/tmp/hello -- bash
<span class="go">ch-run[1184427]: error: can&#39;t mkdir: /var/tmp/hello/var/tmp/foo0: Read-only file system (ch_misc.c:142 30)</span>
<span class="gp">$</span> ch-run -b /var/tmp/foo0:/mnt/0 -b /var/tmp/foo1:/mnt/1 /var/tmp/hello -- bash
<span class="gp">&gt;</span> ls /mnt
<span class="go">0  1  2  3  4  5  6  7  8  9</span>
<span class="gp">&gt;</span> cat /mnt/0/bar
<span class="go">hello</span>
<span class="gp">&gt;</span> cat /mnt/1/bar
<span class="go">world</span>
</pre></div>
</div>
</section>
<section id="network">
<h3><a class="toc-backref" href="#id11"><span class="section-number">2.4.2. </span>Network</a><a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h3>
<p>Charliecloud containers share the host’s network namespace, so most network
things should be the same.</p>
<p>However, SSH is not aware of Charliecloud containers. If you SSH to a node
where Charliecloud is installed, you will get a shell on the host, not in a
container, even if <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> was initiated from a container:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- /bin/bash
<span class="gp">&gt;</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
<span class="gp">&gt;</span> ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
</pre></div>
</div>
<p>There are several ways to SSH to a remote node and run commands inside a
container. The simplest is to manually invoke <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> in the
<code class="code docutils literal notranslate"><span class="pre">ssh</span></code> command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh localhost ch-run /var/tmp/hello.sqfs -- stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Recall that each <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> invocation creates a new container. That
is, the <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> command above has not entered an existing user
namespace <code class="code docutils literal notranslate"><span class="pre">’2256</span></code>; rather, it has re-used the namespace ID
<code class="code docutils literal notranslate"><span class="pre">’2256</span></code>.</p>
</div>
<p>Another is to use the <code class="code docutils literal notranslate"><span class="pre">ch-ssh</span></code> wrapper program, which adds
<code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> to the <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> command implicitly. It takes the
<code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> arguments from the environment variable <code class="code docutils literal notranslate"><span class="pre">CH_RUN_ARGS</span></code>,
making it mostly a drop-in replacement for <code class="code docutils literal notranslate"><span class="pre">ssh</span></code>. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">export</span> <span class="nv">CH_RUN_ARGS</span><span class="o">=</span><span class="s2">&quot;/var/tmp/hello.sqfs --&quot;</span>
<span class="gp">$</span> ch-ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
<span class="gp">$</span> ch-ssh -t localhost /bin/bash
<span class="gp">&gt;</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">ch-ssh</span></code> is available inside containers as well (in <code class="code docutils literal notranslate"><span class="pre">/usr/bin</span></code> via
bind-mount):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">export</span> <span class="nv">CH_RUN_ARGS</span><span class="o">=</span><span class="s2">&quot;/var/tmp/hello.sqfs --&quot;</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- /bin/bash
<span class="gp">&gt;</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
<span class="gp">&gt;</span> ch-ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532258</span>
</pre></div>
</div>
<p>This also demonstrates that <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> does not alter most environment
variables.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ol class="arabic simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">CH_RUN_ARGS</span></code> is interpreted very simply; the sole delimiter is
spaces. It is not shell syntax. In particular, quotes and backslashes
are not interpreted.</p></li>
<li><p>Argument <code class="code docutils literal notranslate"><span class="pre">-t</span></code> is required for SSH to allocate a pseudo-TTY and
thus convince your shell to be interactive. In the case of Bash,
otherwise you’ll get a shell that accepts commands but doesn’t print
prompts, among other other issues. (<a class="reference external" href="https://github.com/hpc/charliecloud/issues/2">Issue #2</a>.)</p></li>
</ol>
</div>
<p>A third may be to edit one’s shell initialization scripts to check the command
line and <code class="code docutils literal notranslate"><span class="pre">exec(1)</span></code> <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> if appropriate. This is brittle but
avoids wrapping <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> or altering its command line.</p>
</section>
<section id="user-and-group-ids">
<h3><a class="toc-backref" href="#id12"><span class="section-number">2.4.3. </span>User and group IDs</a><a class="headerlink" href="#user-and-group-ids" title="Permalink to this headline">¶</a></h3>
<p>Unlike Docker and some other container systems, Charliecloud tries to make the
container’s users and groups look the same as the host’s. (This is
accomplished by bind-mounting a custom <code class="code docutils literal notranslate"><span class="pre">/etc/passwd</span></code> and
<code class="code docutils literal notranslate"><span class="pre">/etc/group</span></code> into the container.) For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> id -u
<span class="go">901</span>
<span class="gp">$</span> whoami
<span class="go">reidpr</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> id -u
<span class="go">901</span>
<span class="gp">&gt;</span> whoami
<span class="go">reidpr</span>
</pre></div>
</div>
<p>More specifically, the user namespace, when created without privileges as
Charliecloud does, lets you map any container UID to your host UID.
<code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> implements this with the <code class="code docutils literal notranslate"><span class="pre">--uid</span></code> switch. So, for example,
you can tell Charliecloud you want to be root, and it will tell you that
you’re root:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --uid <span class="m">0</span> /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> id -u
<span class="go">0</span>
<span class="gp">&gt;</span> whoami
<span class="go">root</span>
</pre></div>
</div>
<p>But, this doesn’t get you anything useful, because the container UID is mapped
back to your UID on the host before permission checks are applied:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> dd <span class="k">if</span><span class="o">=</span>/dev/mem <span class="nv">of</span><span class="o">=</span>/tmp/pwned
<span class="go">dd: failed to open &#39;/dev/mem&#39;: Permission denied</span>
</pre></div>
</div>
<p>This mapping also affects how users are displayed. For example, if a file is
owned by you, your host UID will be mapped to your container UID, which is
then looked up in <code class="code docutils literal notranslate"><span class="pre">/etc/passwd</span></code> to determine the display name. In
typical usage without <code class="code docutils literal notranslate"><span class="pre">--uid</span></code>, this mapping is a no-op, so everything
looks normal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -nd ~
<span class="go">drwxr-xr-x 87 901 901 4096 Sep 28 12:12 /home/reidpr</span>
<span class="gp">$</span> ls -ld ~
<span class="go">drwxr-xr-x 87 reidpr reidpr 4096 Sep 28 12:12 /home/reidpr</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -nd ~
<span class="go">drwxr-xr-x 87 901 901 4096 Sep 28 18:12 /home/reidpr</span>
<span class="gp">&gt;</span> ls -ld ~
<span class="go">drwxr-xr-x 87 reidpr reidpr 4096 Sep 28 18:12 /home/reidpr</span>
</pre></div>
</div>
<p>But if <code class="code docutils literal notranslate"><span class="pre">--uid</span></code> is provided, things can seem odd. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --uid <span class="m">0</span> /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -nd /home/reidpr
<span class="go">drwxr-xr-x 87 0 901 4096 Sep 28 18:12 /home/reidpr</span>
<span class="gp">&gt;</span> ls -ld /home/reidpr
<span class="go">drwxr-xr-x 87 root reidpr 4096 Sep 28 18:12 /home/reidpr</span>
</pre></div>
</div>
<p>This UID mapping can contain only one pair: an arbitrary container UID to your
effective UID on the host. Thus, all other users are unmapped, and they show
up as <code class="code docutils literal notranslate"><span class="pre">nobody</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -n /tmp/foo
<span class="go">-rw-rw---- 1 902 902 0 Sep 28 15:40 /tmp/foo</span>
<span class="gp">$</span> ls -l /tmp/foo
<span class="go">-rw-rw---- 1 sig sig 0 Sep 28 15:40 /tmp/foo</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -n /tmp/foo
<span class="go">-rw-rw---- 1 65534 65534 843 Sep 28 21:40 /tmp/foo</span>
<span class="gp">&gt;</span> ls -l /tmp/foo
<span class="go">-rw-rw---- 1 nobody nogroup 843 Sep 28 21:40 /tmp/foo</span>
</pre></div>
</div>
<p>User namespaces have a similar mapping for GIDs, with the same limitation —
exactly one arbitrary container GID maps to your effective <em>primary</em> GID. This
can lead to some strange-looking results, because only one of your GIDs can be
mapped in any given container. All the rest become <code class="code docutils literal notranslate"><span class="pre">nogroup</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> id
<span class="go">uid=901(reidpr) gid=901(reidpr) groups=901(reidpr),903(nerds),904(losers)</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- id
<span class="go">uid=901(reidpr) gid=901(reidpr) groups=901(reidpr),65534(nogroup)</span>
<span class="gp">$</span> ch-run --gid <span class="m">903</span> /var/tmp/hello.sqfs -- id
<span class="go">uid=901(reidpr) gid=903(nerds) groups=903(nerds),65534(nogroup)</span>
</pre></div>
</div>
<p>However, this doesn’t affect access. The container process retains the same
GIDs from the host perspective, and as always, the host IDs are what control
access:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /tmp/primary /tmp/supplemental
<span class="go">-rw-rw---- 1 sig reidpr 0 Sep 28 15:47 /tmp/primary</span>
<span class="go">-rw-rw---- 1 sig nerds  0 Sep 28 15:48 /tmp/supplemental</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> cat /tmp/primary &gt; /dev/null
<span class="gp">&gt;</span> cat /tmp/supplemental &gt; /dev/null
</pre></div>
</div>
<p>One area where functionality <em>is</em> reduced is that <code class="code docutils literal notranslate"><span class="pre">chgrp(1)</span></code> becomes
useless. Using an unmapped group or <code class="code docutils literal notranslate"><span class="pre">nogroup</span></code> fails, and using a mapped
group is a no-op because it’s mapped back to the host GID:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /tmp/bar
<span class="go">rw-rw---- 1 reidpr reidpr 0 Sep 28 16:12 /tmp/bar</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- chgrp nerds /tmp/bar
<span class="go">chgrp: changing group of &#39;/tmp/bar&#39;: Invalid argument</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- chgrp nogroup /tmp/bar
<span class="go">chgrp: changing group of &#39;/tmp/bar&#39;: Invalid argument</span>
<span class="gp">$</span> ch-run --gid <span class="m">903</span> /var/tmp/hello.sqfs -- chgrp nerds /tmp/bar
<span class="gp">$</span> ls -l /tmp/bar
<span class="go">-rw-rw---- 1 reidpr reidpr 0 Sep 28 16:12 /tmp/bar</span>
</pre></div>
</div>
<p>Workarounds include <code class="code docutils literal notranslate"><span class="pre">chgrp(1)</span></code> on the host or fastidious use of setgid
directories:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /tmp/baz
<span class="gp">$</span> chgrp nerds /tmp/baz
<span class="gp">$</span> chmod <span class="m">2770</span> /tmp/baz
<span class="gp">$</span> ls -ld /tmp/baz
<span class="go">drwxrws--- 2 reidpr nerds 40 Sep 28 16:19 /tmp/baz</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- touch /tmp/baz/foo
<span class="gp">$</span> ls -l /tmp/baz/foo
<span class="go">-rw-rw---- 1 reidpr nerds 0 Sep 28 16:21 /tmp/baz/foo</span>
</pre></div>
</div>
<p>This concludes our discussion of how a Charliecloud container interacts with
its host and principal Charliecloud quirks. We next move on to installing
software.</p>
</section>
</section>
<section id="installing-your-own-software">
<h2><a class="toc-backref" href="#id13"><span class="section-number">2.5. </span>Installing your own software</a><a class="headerlink" href="#installing-your-own-software" title="Permalink to this headline">¶</a></h2>
<p>This section covers four situations for making software available inside a
Charliecloud container:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Third-party software installed into the image using a package manager.</p></li>
<li><p>Third-party software compiled from source into the image.</p></li>
<li><p>Your software installed into the image.</p></li>
<li><p>Your software stored on the host but compiled in the container.</p></li>
</ol>
</div></blockquote>
<p>Many of Docker’s <a class="reference external" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices">Best practices for writing Dockerfiles</a>
apply to Charliecloud images as well, so you should be familiar with that
document.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Maybe you don’t have to install the software at all. Is there already a
trustworthy image on Docker Hub you can use as a base?</p>
</div>
<section id="third-party-software-via-package-manager">
<h3><a class="toc-backref" href="#id14"><span class="section-number">2.5.1. </span>Third-party software via package manager</a><a class="headerlink" href="#third-party-software-via-package-manager" title="Permalink to this headline">¶</a></h3>
<p>This approach is the simplest and fastest way to install stuff in your image.
The <code class="code docutils literal notranslate"><span class="pre">examples/hello</span></code> Dockerfile also seen above does this to install the
package <code class="code docutils literal notranslate"><span class="pre">openssh-client</span></code>:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">RUN</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> openssh-clients <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf clean all

<span class="k">COPY</span> . hello
</pre></div>
</div>
<p>You can use distribution package managers such as <code class="code docutils literal notranslate"><span class="pre">dnf</span></code>, as
demonstrated above, or others, such as <code class="code docutils literal notranslate"><span class="pre">pip</span></code> for Python packages.</p>
<p>Be aware that the software will be downloaded anew each time you build the
image, unless you add an HTTP cache, which is out of scope of this tutorial.</p>
</section>
<section id="third-party-software-compiled-from-source">
<h3><a class="toc-backref" href="#id15"><span class="section-number">2.5.2. </span>Third-party software compiled from source</a><a class="headerlink" href="#third-party-software-compiled-from-source" title="Permalink to this headline">¶</a></h3>
<p>Under this method, one uses <code class="code docutils literal notranslate"><span class="pre">RUN</span></code> commands to fetch the desired software
using <code class="code docutils literal notranslate"><span class="pre">curl</span></code> or <code class="code docutils literal notranslate"><span class="pre">wget</span></code>, compile it, and install. Our example does
this with two chained Dockerfiles. First, we build a basic CentOS image
(<code class="code docutils literal notranslate"><span class="pre">examples/Dockerfile.almalinux8</span></code>):</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">almalinux:8</span>

<span class="c"># This image has two purposes: (1) demonstrate we can build a AlmaLinux 8 image</span>
<span class="c"># and (2) provide a build environment for Charliecloud EPEL 8 RPMs.</span>
<span class="c">#</span>
<span class="c"># Quirks:</span>
<span class="c">#</span>
<span class="c">#   1. Install the dnf ovl plugin to work around RPMDB corruption when</span>
<span class="c">#      building images with Docker and the OverlayFS storage driver.</span>
<span class="c">#</span>
<span class="c">#   2. Enable PowerTools repo, because some packages in EPEL depend on it.</span>
<span class="c">#</span>
<span class="c">#   3. Install packages needed to build el8 rpms.</span>
<span class="c">#</span>
<span class="c">#   4. Issue #1103: Install libarchive to resolve cmake bug</span>
<span class="c">#</span>
<span class="k">RUN</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> <span class="se">\</span>
                epel-release <span class="se">\</span>
                <span class="s1">&#39;dnf-command(config-manager)&#39;</span> <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf config-manager --enable powertools <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> <span class="se">\</span>
                dnf-plugin-ovl <span class="se">\</span>
                autoconf <span class="se">\</span>
                automake <span class="se">\</span>
                gcc <span class="se">\</span>
                git <span class="se">\</span>
                libarchive <span class="se">\</span>
                make <span class="se">\</span>
                python3 <span class="se">\</span>
                python3-devel <span class="se">\</span>
                python3-lark-parser <span class="se">\</span>
                python3-requests <span class="se">\</span>
                python3-sphinx <span class="se">\</span>
                python3-sphinx_rtd_theme <span class="se">\</span>
                rpm-build <span class="se">\</span>
                rpmlint <span class="se">\</span>
                rsync <span class="se">\</span>
                squashfs-tools <span class="se">\</span>
                squashfuse <span class="se">\</span>
                wget <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf clean all

<span class="c"># Need wheel to install bundled Lark, and the RPM version doesn&#39;t work.</span>
<span class="k">RUN</span> pip3 install wheel

<span class="c"># AlmaLinux&#39;s linker doesn&#39;t search these paths by default; add them because we</span>
<span class="c"># will install stuff later into /usr/local.</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;/usr/local/lib&quot;</span> &gt; /etc/ld.so.conf.d/usrlocal.conf <span class="se">\</span>
 <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;/usr/local/lib64&quot;</span> &gt;&gt; /etc/ld.so.conf.d/usrlocal.conf <span class="se">\</span>
 <span class="o">&amp;&amp;</span> ldconfig
</pre></div>
</div>
<p>Then, we add OpenMPI with <code class="code docutils literal notranslate"><span class="pre">examples/Dockerfile.openmpi</span></code>. This is a complex
Dockerfile that compiles several dependencies in addition to OpenMPI. For the
purposes of this tutorial, you can skip most of it, but we felt it would be
useful to show a real example.</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">almalinux8</span>

<span class="c"># A key goal of this Dockerfile is to demonstrate best practices for building</span>
<span class="c"># OpenMPI for use inside a container.</span>
<span class="c">#</span>
<span class="c"># This OpenMPI aspires to work close to optimally on clusters with any of the</span>
<span class="c"># following interconnects:</span>
<span class="c">#</span>
<span class="c">#    - Ethernet (TCP/IP)</span>
<span class="c">#    - InfiniBand (IB)</span>
<span class="c">#    - Omni-Path (OPA)</span>
<span class="c">#    - RDMA over Converged Ethernet (RoCE) interconnects</span>
<span class="c">#</span>
<span class="c"># with no environment variables, command line arguments, or additional</span>
<span class="c"># configuration files. Thus, we try to implement decisions at build time.</span>
<span class="c">#</span>
<span class="c"># This is a work in progress, and we&#39;re very interested in feedback.</span>
<span class="c">#</span>
<span class="c"># OpenMPI has numerous ways to communicate messages [1]. The ones relevant to</span>
<span class="c"># this build and the interconnects they support are:</span>
<span class="c">#</span>
<span class="c">#   Module        Eth   IB    OPA   RoCE    note  decision</span>
<span class="c">#   ------------  ----  ----  ----  ----    ----  --------</span>
<span class="c">#</span>
<span class="c">#   ob1 : tcp      Y*    X     X     X      a     include</span>
<span class="c">#   ob1 : openib   N     Y     Y     Y      b,c   exclude</span>
<span class="c">#   cm  : psm2     N     N     Y*    N            include</span>
<span class="c">#       : ucx      Y?    Y*    N     Y?     b,d   include</span>
<span class="c">#</span>
<span class="c">#   Y : supported</span>
<span class="c">#   Y*: best choice for that interconnect</span>
<span class="c">#   X : supported but sub-optimal</span>
<span class="c">#</span>
<span class="c">#   a : No RDMA, so performance will suffer.</span>
<span class="c">#   b : Uses libibverbs.</span>
<span class="c">#   c : Will be removed in OpenMPI 5.</span>
<span class="c">#   d : Uses Mellanox libraries if available in preference to libibverbs.</span>
<span class="c">#</span>
<span class="c"># You can check what&#39;s available with:</span>
<span class="c">#</span>
<span class="c">#   $ ch-run /var/tmp/openmpi -- ompi_info | egrep &#39;(btl|mtl|pml)&#39;</span>
<span class="c">#</span>
<span class="c"># The other build decisions are:</span>
<span class="c">#</span>
<span class="c">#   1. PMI/PMIx: Include these so that we can use srun or any other PMI[x]</span>
<span class="c">#      provider, with no matching OpenMPI needed on the host.</span>
<span class="c">#</span>
<span class="c">#   2. --disable-pty-support to avoid &quot;pipe function call failed when</span>
<span class="c">#      setting up I/O forwarding subsystem&quot;.</span>
<span class="c">#</span>
<span class="c">#   3. --enable-mca-no-build=plm-slurm to support launching processes using</span>
<span class="c">#      the host&#39;s srun (i.e., the container OpenMPI needs to talk to the host</span>
<span class="c">#      Slurm&#39;s PMI) but prevent OpenMPI from invoking srun itself from within</span>
<span class="c">#      the container, where srun is not installed (the error messages from</span>
<span class="c">#      this are inscrutable).</span>
<span class="c">#</span>
<span class="c"># [1]: https://github.com/open-mpi/ompi/blob/master/README</span>

<span class="c"># OS packages needed to build this stuff.</span>
<span class="c">#</span>
<span class="c"># Note that libpsm2 is x86-64 only so we skip if missing</span>
<span class="k">RUN</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> <span class="se">\</span>
                automake <span class="se">\</span>
                file <span class="se">\</span>
                flex <span class="se">\</span>
                gcc <span class="se">\</span>
                gcc-c++ <span class="se">\</span>
                gcc-gfortran <span class="se">\</span>
                git <span class="se">\</span>
                ibacm <span class="se">\</span>
                libevent-devel <span class="se">\</span>
                libtool <span class="se">\</span>
                libibumad <span class="se">\</span>
                libibumad-devel <span class="se">\</span>
                libibverbs <span class="se">\</span>
                libibverbs-devel <span class="se">\</span>
                libibverbs-utils <span class="se">\</span>
                librdmacm <span class="se">\</span>
                librdmacm-devel <span class="se">\</span>
                rdma-core <span class="se">\</span>
                make <span class="se">\</span>
                numactl-devel <span class="se">\</span>
                wget <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf install -y --setopt<span class="o">=</span><span class="nv">install_weak_deps</span><span class="o">=</span><span class="nb">false</span> --skip-broken <span class="se">\</span>
                libpsm2 <span class="se">\</span>
                libpsm2-devel <span class="se">\</span>
 <span class="o">&amp;&amp;</span> dnf clean all

<span class="k">WORKDIR</span><span class="s"> /usr/local/src</span>

<span class="c"># UCX. There is a package but we want control over build options, specifically</span>
<span class="c"># multithreaded support.</span>
<span class="k">ARG</span> <span class="nv">UCX_VERSION</span><span class="o">=</span><span class="m">1</span>.11.2
<span class="k">RUN</span> git clone --branch v<span class="si">${</span><span class="nv">UCX_VERSION</span><span class="si">}</span> --depth <span class="m">1</span> <span class="se">\</span>
              https://github.com/openucx/ucx.git <span class="se">\</span>
 <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ucx <span class="se">\</span>
 <span class="o">&amp;&amp;</span> ./autogen.sh <span class="se">\</span>
 <span class="o">&amp;&amp;</span> ./contrib/configure-release-mt --prefix<span class="o">=</span>/usr/local <span class="se">\</span>
 <span class="o">&amp;&amp;</span> make -j<span class="k">$(</span>getconf _NPROCESSORS_ONLN<span class="k">)</span> install <span class="se">\</span>
 <span class="o">&amp;&amp;</span> rm -Rf ../ucx*

<span class="c"># PMI2.</span>
<span class="c">#</span>
<span class="c"># There isn&#39;t a package available with the Slurm PMI2 libraries we need, so</span>
<span class="c"># build them from Slurm&#39;s release.</span>
<span class="k">ARG</span> <span class="nv">SLURM_VERSION</span><span class="o">=</span><span class="m">19</span>-05-3-2
<span class="k">RUN</span> wget https://github.com/SchedMD/slurm/archive/slurm-<span class="si">${</span><span class="nv">SLURM_VERSION</span><span class="si">}</span>.tar.gz <span class="se">\</span>
 <span class="o">&amp;&amp;</span> tar -xf slurm-<span class="si">${</span><span class="nv">SLURM_VERSION</span><span class="si">}</span>.tar.gz <span class="se">\</span>
 <span class="o">&amp;&amp;</span> <span class="nb">cd</span> slurm-slurm-<span class="si">${</span><span class="nv">SLURM_VERSION</span><span class="si">}</span> <span class="se">\</span>
 <span class="o">&amp;&amp;</span> ./configure --prefix<span class="o">=</span>/usr/local <span class="se">\</span>
 <span class="o">&amp;&amp;</span> <span class="nb">cd</span> contribs/pmi2 <span class="se">\</span>
 <span class="o">&amp;&amp;</span> make -j<span class="k">$(</span>getconf _NPROCESSORS_ONLN<span class="k">)</span> install <span class="se">\</span>
 <span class="o">&amp;&amp;</span> rm -Rf ../../../slurm*

<span class="c"># OpenMPI.</span>
<span class="c">#</span>
<span class="c"># Patch OpenMPI to disable UCX plugin on systems with Intel or Cray HSNs. UCX</span>
<span class="c"># has inferior performance than PSM2/uGNI but higher priority.</span>
<span class="k">ARG</span> <span class="nv">MPI_URL</span><span class="o">=</span>https://www.open-mpi.org/software/ompi/v3.1/downloads
<span class="k">ARG</span> <span class="nv">MPI_VERSION</span><span class="o">=</span><span class="m">3</span>.1.6
<span class="k">RUN</span> wget -nv <span class="si">${</span><span class="nv">MPI_URL</span><span class="si">}</span>/openmpi-<span class="si">${</span><span class="nv">MPI_VERSION</span><span class="si">}</span>.tar.gz <span class="se">\</span>
 <span class="o">&amp;&amp;</span> tar xf openmpi-<span class="si">${</span><span class="nv">MPI_VERSION</span><span class="si">}</span>.tar.gz
<span class="k">COPY</span> dont-init-ucx-on-intel-cray.patch ./openmpi-<span class="si">${</span><span class="nv">MPI_VERSION</span><span class="si">}</span>
<span class="k">RUN</span> <span class="nb">cd</span> openmpi-<span class="si">${</span><span class="nv">MPI_VERSION</span><span class="si">}</span> <span class="se">\</span>
 <span class="o">&amp;&amp;</span> patch -p1 dont-init-ucx-on-intel-cray.patch <span class="se">\</span>
 <span class="o">&amp;&amp;</span> <span class="nv">CFLAGS</span><span class="o">=</span>-O3 <span class="se">\</span>
    <span class="nv">CXXFLAGS</span><span class="o">=</span>-O3 <span class="se">\</span>
    ./configure --prefix<span class="o">=</span>/usr/local <span class="se">\</span>
                --sysconfdir<span class="o">=</span>/mnt/0 <span class="se">\</span>
                --with-slurm <span class="se">\</span>
                --with-pmi<span class="o">=</span>/usr/local <span class="se">\</span>
                --with-pmix <span class="se">\</span>
                --with-ucx <span class="se">\</span>
                --disable-pty-support <span class="se">\</span>
                --enable-mca-no-build<span class="o">=</span>btl-openib,plm-slurm <span class="se">\</span>
 <span class="o">&amp;&amp;</span> make -j<span class="k">$(</span>getconf _NPROCESSORS_ONLN<span class="k">)</span> install <span class="se">\</span>
 <span class="o">&amp;&amp;</span> rm -Rf ../openmpi-<span class="si">${</span><span class="nv">MPI_VERSION</span><span class="si">}</span>*
<span class="k">RUN</span> ldconfig

<span class="c"># OpenMPI expects this program to exist, even if it&#39;s not used. Default is</span>
<span class="c"># &quot;ssh : rsh&quot;, but that&#39;s not installed.</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s1">&#39;plm_rsh_agent = false&#39;</span> &gt;&gt; /mnt/0/openmpi-mca-params.conf
</pre></div>
</div>
<p>So what is going on here?</p>
<ol class="arabic simple">
<li><p>Use the latest AlmaLinux 8 as the base image.</p></li>
<li><p>Install a basic build system using the OS package manager.</p></li>
<li><p>For a few dependencies and then OpenMPI itself:</p>
<ol class="arabic simple">
<li><p>Download and untar. Note the use of variables to make adjusting the URL
and versions easier, as well as the explanation of why we’re not using
<code class="code docutils literal notranslate"><span class="pre">dnf</span></code>, given that several of these packages are included in
CentOS.</p></li>
<li><p>Build and install OpenMPI. Note the <code class="code docutils literal notranslate"><span class="pre">getconf</span></code> trick to guess at an
appropriate parallel build.</p></li>
</ol>
</li>
<li><p>Clean up, in order to reduce the size of layers as well as the resulting
Charliecloud image (<code class="code docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-Rf</span></code>).</p></li>
</ol>
</section>
<section id="your-software-stored-in-the-image">
<h3><a class="toc-backref" href="#id16"><span class="section-number">2.5.3. </span>Your software stored in the image</a><a class="headerlink" href="#your-software-stored-in-the-image" title="Permalink to this headline">¶</a></h3>
<p>This method covers software provided by you that is included in the image.
This is recommended when your software is relatively stable or is not easily
available to users of your image, for example a library rather than simulation
code under active development.</p>
<p>The general approach is the same as installing third-party software from
source, but you use the <code class="code docutils literal notranslate"><span class="pre">COPY</span></code> instruction to transfer files from the
host filesystem (rather than the network via HTTP) to the image. For example,
<code class="code docutils literal notranslate"><span class="pre">examples/mpihello/Dockerfile.openmpi</span></code> uses this approach:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># ch-test-scope: full</span>
<span class="k">FROM</span> <span class="s">openmpi</span>

<span class="c"># This example</span>
<span class="k">COPY</span> . /hello
<span class="k">WORKDIR</span><span class="s"> /hello</span>
<span class="k">RUN</span> make clean <span class="o">&amp;&amp;</span> make
</pre></div>
</div>
<p>These Dockerfile instructions:</p>
<ol class="arabic">
<li><p>Copy the host directory <code class="code docutils literal notranslate"><span class="pre">examples/mpihello</span></code> to the image at path
<code class="code docutils literal notranslate"><span class="pre">/hello</span></code>. The host path is relative to the <em>context directory</em>, which
is tarred up and sent to the Docker daemon. Docker builds have no access to
the host filesystem outside the context directory.</p>
<p>(Unlike the HPC custom, Docker comes from a world without network
filesystems. This tar-based approach lets the Docker daemon run on a
different node from the client without needing any shared filesystems.)</p>
<p>The convention for Charliecloud tests and examples is that the context is
the directory containing the Dockerfile in question, and a common pattern,
used here, is to copy in the entire context.</p>
</li>
<li><p><code class="code docutils literal notranslate"><span class="pre">cd</span></code> to <code class="code docutils literal notranslate"><span class="pre">/hello</span></code>.</p></li>
<li><p>Compile our example. We include <code class="code docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> to remove any leftover
build files, since they would be inappropriate inside the container.</p></li>
</ol>
<p>Once the image is built, we can see the results. (Install the image into
<code class="code docutils literal notranslate"><span class="pre">/var/tmp</span></code> as outlined above, if you haven’t already.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run /var/tmp/mpihello-openmpi.sqfs -- ls -lh /hello
<span class="go">total 32K</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  908 Oct  4 15:52 Dockerfile</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  157 Aug  5 22:37 Makefile</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1.2K Aug  5 22:37 README</span>
<span class="go">-rwxr-x--- 1 reidpr reidpr 9.5K Oct  4 15:58 hello</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1.4K Aug  5 22:37 hello.c</span>
<span class="go">-rwxrwx--- 1 reidpr reidpr  441 Aug  5 22:37 test.sh</span>
</pre></div>
</div>
<p>We will revisit this image later.</p>
</section>
<section id="your-software-stored-on-the-host">
<h3><a class="toc-backref" href="#id17"><span class="section-number">2.5.4. </span>Your software stored on the host</a><a class="headerlink" href="#your-software-stored-on-the-host" title="Permalink to this headline">¶</a></h3>
<p>This method leaves your software on the host but compiles it in the image.
This is recommended when your software is volatile or each image user needs a
different version, for example a simulation code under active development.</p>
<p>The general approach is to bind-mount the appropriate directory and then run
the build inside the container. We can re-use the <code class="code docutils literal notranslate"><span class="pre">mpihello</span></code> image to
demonstrate this.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> examples/mpihello
<span class="gp">$</span> ls -l
<span class="go">total 20</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  908 Oct  4 09:52 Dockerfile</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1431 Aug  5 16:37 hello.c</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  157 Aug  5 16:37 Makefile</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1172 Aug  5 16:37 README</span>
<span class="gp">$</span> ch-run -b .:/mnt/0 --cd /mnt/0 /var/tmp/mpihello.sqfs -- make
<span class="go">mpicc -std=gnu11 -Wall hello.c -o hello</span>
<span class="gp">$</span> ls -l
<span class="go">total 32</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  908 Oct  4 09:52 Dockerfile</span>
<span class="go">-rwxrwx--- 1 reidpr reidpr 9632 Oct  4 10:43 hello</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1431 Aug  5 16:37 hello.c</span>
<span class="go">-rw-rw---- 1 reidpr reidpr  157 Aug  5 16:37 Makefile</span>
<span class="go">-rw-rw---- 1 reidpr reidpr 1172 Aug  5 16:37 README</span>
</pre></div>
</div>
<p>A common use case is to leave a container shell open in one terminal for
building, and then run using a separate container invoked from a different
terminal.</p>
</section>
</section>
<section id="your-first-single-node-multi-process-jobs">
<h2><a class="toc-backref" href="#id18"><span class="section-number">2.6. </span>Your first single-node, multi-process jobs</a><a class="headerlink" href="#your-first-single-node-multi-process-jobs" title="Permalink to this headline">¶</a></h2>
<p>This is an important use case even for large-scale codes, when testing and
development happens at small scale but need to use an environment comparable
to large-scale runs.</p>
<p>This tutorial covers three approaches:</p>
<ol class="arabic simple">
<li><p>Processes are coordinated by the host, i.e., one process per container.</p></li>
<li><p>Processes are coordinated by the container, i.e., one container with
multiple processes, using configuration files from the container.</p></li>
<li><p>Processes are coordinated by the container using configuration files from
the host.</p></li>
</ol>
<p>In order to test approach 1, you must install OpenMPI 2.1.2 on the host.
In our experience, we have had success compiling from source with the same
options as in the Dockerfile, but there is probably more nuance to the match
than we’ve discovered.</p>
<section id="processes-coordinated-by-host">
<h3><a class="toc-backref" href="#id19"><span class="section-number">2.6.1. </span>Processes coordinated by host</a><a class="headerlink" href="#processes-coordinated-by-host" title="Permalink to this headline">¶</a></h3>
<p>This approach does the forking and process coordination on the host. Each
process is spawned in its own container, and because Charliecloud introduces
minimal isolation, they can communicate as if they were running directly on
the host.</p>
<p>For example, using Slurm <code class="code docutils literal notranslate"><span class="pre">srun</span></code> and the <code class="code docutils literal notranslate"><span class="pre">mpihello</span></code> example above:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ch-run /var/tmp/mpihello-openmpi.sqfs -- mpirun --version
<span class="go">mpirun (Open MPI) 2.1.5</span>
<span class="gp">$</span> srun -n4 ch-run /var/tmp/mpihello-openmpi.sqfs -- /hello/hello
<span class="go">0: init ok cn001, 4 ranks, userns 4026554650</span>
<span class="go">1: init ok cn001, 4 ranks, userns 4026554652</span>
<span class="go">3: init ok cn002, 4 ranks, userns 4026554652</span>
<span class="go">2: init ok cn002, 4 ranks, userns 4026554650</span>
<span class="go">0: send/receive ok</span>
<span class="go">0: finalize ok</span>
</pre></div>
</div>
<p>We recommend this approach because it lets you take advantage of difficult
things already done by your site admins, such as configuring Slurm.</p>
<p>If you don’t have Slurm, you can use <code class="code docutils literal notranslate"><span class="pre">mpirun</span> <span class="pre">-np</span> <span class="pre">4</span></code> instead of
<code class="code docutils literal notranslate"><span class="pre">srun</span> <span class="pre">-n4</span></code>. However, this requires that the host have a compatible
version of OpenMPI installed on the host. Which versions are compatible seems
to be a moving target, but having the same versions inside and outside the
container <em>usually</em> works.</p>
</section>
<section id="processes-coordinated-by-container">
<h3><a class="toc-backref" href="#id20"><span class="section-number">2.6.2. </span>Processes coordinated by container</a><a class="headerlink" href="#processes-coordinated-by-container" title="Permalink to this headline">¶</a></h3>
<p>This approach starts a single container process, which then forks and
coordinates the parallel work. The advantage is that this approach is
completely independent of the host for dependency configuration and
installation; the disadvantage is that it cannot take advantage of host things
such as Slurm configuration.</p>
<p>For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run /var/tmp/mpihello-openmpi.sqfs -- mpirun -np <span class="m">4</span> /hello/hello
<span class="go">0: init ok cn001, 4 ranks, userns 4026532256</span>
<span class="go">1: init ok cn001, 4 ranks, userns 4026532256</span>
<span class="go">2: init ok cn001, 4 ranks, userns 4026532256</span>
<span class="go">3: init ok cn001, 4 ranks, userns 4026532256</span>
<span class="go">0: send/receive ok</span>
<span class="go">0: finalize ok</span>
</pre></div>
</div>
<p>Note that in this case, we use <code class="code docutils literal notranslate"><span class="pre">mpirun</span></code> rather than <code class="code docutils literal notranslate"><span class="pre">srun</span></code> because
the Slurm client programs are not installed inside the container, and we don’t
want the host’s Slurm coordinating processes anyway.</p>
</section>
</section>
<section id="your-first-multi-node-jobs">
<h2><a class="toc-backref" href="#id21"><span class="section-number">2.7. </span>Your first multi-node jobs</a><a class="headerlink" href="#your-first-multi-node-jobs" title="Permalink to this headline">¶</a></h2>
<p>This section assumes that you are using a Slurm cluster and some type of
node-local storage. A <code class="code docutils literal notranslate"><span class="pre">tmpfs</span></code> will suffice, and we use <code class="code docutils literal notranslate"><span class="pre">/var/tmp</span></code>
for this tutorial. (Using <code class="code docutils literal notranslate"><span class="pre">/tmp</span></code> often works but can cause confusion
because it’s shared by the container and host, yielding cycles in the
directory tree.)</p>
<p>We cover three cases:</p>
<ol class="arabic simple">
<li><p>The MPI hello world example above, run interactively, with the host
coordinating.</p></li>
<li><p>Same, non-interactive.</p></li>
<li><p>An Apache Spark example, run interactively.</p></li>
<li><p>Same, non-interactive.</p></li>
</ol>
<p>We think that container-coordinated MPI jobs will also work, but we haven’t
worked out how to do this yet. (See <a class="reference external" href="https://github.com/hpc/charliecloud/issues/5">issue #5</a>.)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The image directory is mounted read-only by default so it can be shared by
multiple Charliecloud containers in the same or different jobs. It can be
mounted read-write with <code class="code docutils literal notranslate"><span class="pre">ch-run</span> <span class="pre">-w</span></code> if you are not using SquashFS.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The image can reside on most filesystems, but be aware of metadata impact.
A non-trivial Charliecloud job may overwhelm a network filesystem, earning
you the ire of your sysadmins and colleagues.</p>
</div>
<section id="interactive-mpi-hello-world">
<h3><a class="toc-backref" href="#id22"><span class="section-number">2.7.1. </span>Interactive MPI hello world</a><a class="headerlink" href="#interactive-mpi-hello-world" title="Permalink to this headline">¶</a></h3>
<p>First, obtain an interactive allocation of nodes. This tutorial assumes an
allocation of 4 nodes (but any number should work) and an interactive shell on
one of those nodes. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> salloc -N4
</pre></div>
</div>
<p>The next step is to distribute the image to the compute nodes. For SquashFS
images, this is handled by the internal mounting process; for tarballs, we run
one instance of <code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code> on each node using <code class="code docutils literal notranslate"><span class="pre">srun</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun ch-convert mpihello-openmpi.tar.gz /var/tmp/mpihello-openmpi
<span class="go">input:   tar       mpihello-openmpi.tar.gz</span>
<span class="go">output:  dir       /var/tmp/mpihello-openmpi</span>
<span class="go">unpacking ...</span>
<span class="go">input:   tar       mpihello-openmpi.tar.gz</span>
<span class="go">output:  dir       /var/tmp/mpihello-openmpi</span>
<span class="go">unpacking ...</span>
<span class="go">input:   tar       mpihello-openmpi.tar.gz</span>
<span class="go">output:  dir       /var/tmp/mpihello-openmpi</span>
<span class="go">unpacking ...</span>
<span class="go">input:   tar       mpihello-openmpi.tar.gz</span>
<span class="go">output:  dir       /var/tmp/mpihello-openmpi</span>
<span class="go">unpacking ...</span>
<span class="go">done</span>
<span class="go">done</span>
<span class="go">done</span>
<span class="go">done</span>
</pre></div>
</div>
<p>We can now activate the image and run our program:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun --cpus-per-task<span class="o">=</span><span class="m">1</span> ch-run /var/tmp/mpihello-openmpi.sqfs -- /hello/hello
<span class="go">2: init ok cn001, 64 ranks, userns 4026532567</span>
<span class="go">4: init ok cn001, 64 ranks, userns 4026532571</span>
<span class="go">8: init ok cn001, 64 ranks, userns 4026532579</span>
<span class="go">[...]</span>
<span class="go">45: init ok cn003, 64 ranks, userns 4026532589</span>
<span class="go">17: init ok cn002, 64 ranks, userns 4026532565</span>
<span class="go">55: init ok cn004, 64 ranks, userns 4026532577</span>
<span class="go">0: send/receive ok</span>
<span class="go">0: finalize ok</span>
</pre></div>
</div>
<p>Success!</p>
</section>
<section id="non-interactive-mpi-hello-world">
<h3><a class="toc-backref" href="#id23"><span class="section-number">2.7.2. </span>Non-interactive MPI hello world</a><a class="headerlink" href="#non-interactive-mpi-hello-world" title="Permalink to this headline">¶</a></h3>
<p>Production jobs are normally run non-interactively, via submission of a job
script that runs when resources are available, placing output into a file.</p>
<p>The MPI hello world example includes such a script,
<code class="code docutils literal notranslate"><span class="pre">examples/mpi/mpihello/slurm.sh</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#SBATCH --time=0:10:00</span>

<span class="c1"># Arguments: Path to tarball, path to image parent directory.</span>

<span class="nb">set</span> -e

<span class="nv">tar</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">imgdir</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">img</span><span class="o">=</span><span class="si">${</span><span class="nv">2</span><span class="si">}</span>/<span class="k">$(</span>basename <span class="s2">&quot;</span><span class="si">${</span><span class="nv">tar</span><span class="p">%.tar.gz</span><span class="si">}</span><span class="s2">&quot;</span><span class="k">)</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="nv">$tar</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s1">&#39;no tarball specified&#39;</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="nb">printf</span> <span class="s1">&#39;tarball:   %s\n&#39;</span> <span class="s2">&quot;</span><span class="nv">$tar</span><span class="s2">&quot;</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="nv">$imgdir</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s1">&#39;no image directory specified&#39;</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="nb">printf</span> <span class="s1">&#39;image:     %s\n&#39;</span> <span class="s2">&quot;</span><span class="nv">$img</span><span class="s2">&quot;</span>

<span class="c1"># Make Charliecloud available (varies by site).</span>
module purge
module load friendly-testing
module load charliecloud

<span class="c1"># Unpack image.</span>
srun ch-convert -o dir <span class="s2">&quot;</span><span class="nv">$tar</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$imgdir</span><span class="s2">&quot;</span>

<span class="c1"># MPI version in container.</span>
<span class="nb">printf</span> <span class="s1">&#39;container: &#39;</span>
ch-run <span class="s2">&quot;</span><span class="nv">$img</span><span class="s2">&quot;</span> -- mpirun --version <span class="p">|</span> grep -E <span class="s1">&#39;^mpirun&#39;</span>

<span class="c1"># Run the app.</span>
srun --cpus-per-task<span class="o">=</span><span class="m">1</span> ch-run <span class="s2">&quot;</span><span class="nv">$img</span><span class="s2">&quot;</span> -- /hello/hello
</pre></div>
</div>
<p>Note that this script both unpacks the image and runs it.</p>
<p>Submit it with something like:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sbatch -N4 slurm.sh ~/mpihello-openmpi.tar.gz /var/tmp
<span class="go">207745</span>
</pre></div>
</div>
<p>When the job is complete, look at the output:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat slurm-207745.out
<span class="go">tarball:   /home/reidpr/mpihello-openmpi.tar.gz</span>
<span class="go">image:     /var/tmp/mpihello-openmpi</span>
<span class="go">creating new image /var/tmp/mpihello-openmpi</span>
<span class="go">creating new image /var/tmp/mpihello-openmpi</span>
<span class="go">[...]</span>
<span class="go">/var/tmp/mpihello-openmpi unpacked ok</span>
<span class="go">/var/tmp/mpihello-openmpi unpacked ok</span>
<span class="go">container: mpirun (Open MPI) 2.1.5</span>
<span class="go">0: init ok cn001.localdomain, 144 ranks, userns 4026554766</span>
<span class="go">37: init ok cn002.localdomain, 144 ranks, userns 4026554800</span>
<span class="go">[...]</span>
<span class="go">96: init ok cn003.localdomain, 144 ranks, userns 4026554803</span>
<span class="go">86: init ok cn003.localdomain, 144 ranks, userns 4026554793</span>
<span class="go">0: send/receive ok</span>
<span class="go">0: finalize ok</span>
</pre></div>
</div>
<p>Success!</p>
</section>
<section id="interactive-apache-spark">
<h3><a class="toc-backref" href="#id24"><span class="section-number">2.7.3. </span>Interactive Apache Spark</a><a class="headerlink" href="#interactive-apache-spark" title="Permalink to this headline">¶</a></h3>
<p>This example is in <code class="code docutils literal notranslate"><span class="pre">examples/spark</span></code>. Build a tarball or SquashFS and
upload it to your cluster.</p>
<p>Once you have an interactive job, prepare the image. Recall that for the
SquashFS workflow this is handled by the internal mounting process.</p>
<p>tarball:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun ch-convert spark.tar.gz /var/tmp/spark
<span class="go">input:   tar       spark.tar.gz</span>
<span class="go">output:  dir       /var/tmp/spark</span>
<span class="go">unpacking ...</span>
<span class="go">input:   tar       spark.tar.gz</span>
<span class="go">output:  dir       /var/tmp/spark</span>
<span class="go">unpacking ...</span>
<span class="go">done</span>
<span class="go">done</span>
</pre></div>
</div>
<p>We need to first create a basic configuration for Spark, as the defaults in
the Dockerfile are insufficient. (For real jobs, you’ll want to also configure
performance parameters such as memory use; see <a class="reference external" href="http://spark.apache.org/docs/latest/configuration.html">the documentation</a>.) First:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p ~/sparkconf
<span class="gp">$</span> chmod <span class="m">700</span> ~/sparkconf
</pre></div>
</div>
<p>We’ll want to use the cluster’s high-speed network. For this example, we’ll
find the Spark master’s IP manually:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ip -o -f inet addr show <span class="p">|</span> cut -d/ -f1
<span class="go">1: lo    inet 127.0.0.1</span>
<span class="go">2: eth0  inet 192.168.8.3</span>
<span class="go">8: eth1  inet 10.8.8.3</span>
</pre></div>
</div>
<p>Your site support can tell you which to use. In this case, we’ll use 10.8.8.3.</p>
<p>Create some configuration files. Replace <code class="code docutils literal notranslate"><span class="pre">[MYSECRET]</span></code> with a string only
you know. Edit to match your system; in particular, use local disks instead of
<code class="code docutils literal notranslate"><span class="pre">/tmp</span></code> if you have them:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt; ~/sparkconf/spark-env.sh
<span class="go">SPARK_LOCAL_DIRS=/tmp/spark</span>
<span class="go">SPARK_LOG_DIR=/tmp/spark/log</span>
<span class="go">SPARK_WORKER_DIR=/tmp/spark</span>
<span class="go">SPARK_LOCAL_IP=127.0.0.1</span>
<span class="go">SPARK_MASTER_HOST=10.8.8.3</span>
<span class="gp">$</span> cat &gt; ~/sparkconf/spark-defaults.conf
<span class="go">spark.authenticate true</span>
<span class="go">spark.authenticate.secret [MYSECRET]</span>
</pre></div>
</div>
<p>We can now start the Spark master:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- /spark/sbin/start-master.sh
</pre></div>
</div>
<p>Look at the log in <code class="code docutils literal notranslate"><span class="pre">/tmp/spark/log</span></code> to see that the master started
correctly:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -7 /tmp/spark/log/*master*.out
<span class="go">17/02/24 22:37:21 INFO Master: Starting Spark master at spark://10.8.8.3:7077</span>
<span class="go">17/02/24 22:37:21 INFO Master: Running Spark version 2.0.2</span>
<span class="go">17/02/24 22:37:22 INFO Utils: Successfully started service &#39;MasterUI&#39; on port 8080.</span>
<span class="go">17/02/24 22:37:22 INFO MasterWebUI: Bound MasterWebUI to 127.0.0.1, and started at http://127.0.0.1:8080</span>
<span class="go">17/02/24 22:37:22 INFO Utils: Successfully started service on port 6066.</span>
<span class="go">17/02/24 22:37:22 INFO StandaloneRestServer: Started REST server for submitting applications on port 6066</span>
<span class="go">17/02/24 22:37:22 INFO Master: I have been elected leader! New state: ALIVE</span>
</pre></div>
</div>
<p>If you can run a web browser on the node, browse to
<code class="code docutils literal notranslate"><span class="pre">http://localhost:8080</span></code> for the Spark master web interface. Because this
capability varies, the tutorial does not depend on it, but it can be
informative. Refresh after each key step below.</p>
<p>The Spark workers need to know how to reach the master. This is via a URL; you
can get it from the log excerpt above, or consult the web interface. For
example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nv">MASTER_URL</span><span class="o">=</span>spark://10.8.8.3:7077
</pre></div>
</div>
<p>Next, start one worker on each compute node.</p>
<p>In this tutorial, we start the workers using <code class="code docutils literal notranslate"><span class="pre">srun</span></code> in a way that
prevents any subsequent <code class="code docutils literal notranslate"><span class="pre">srun</span></code> invocations from running until the Spark
workers exit. For our purposes here, that’s OK, but it’s a big limitation for
some jobs. (See <a class="reference external" href="https://github.com/hpc/charliecloud/issues/230">issue #230</a>.)</p>
<p>Alternatives include <code class="code docutils literal notranslate"><span class="pre">pdsh</span></code>, which is the approach we use for the Spark
tests (<code class="code docutils literal notranslate"><span class="pre">examples/other/spark/test.bats</span></code>), or a simple for loop of
<code class="code docutils literal notranslate"><span class="pre">ssh</span></code> calls. Both of these are also quite clunky and do not scale well.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun sh -c <span class="s2">&quot;   ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- \</span>
<span class="s2">                        spark/sbin/start-slave.sh </span><span class="nv">$MASTER_URL</span><span class="s2"> \</span>
<span class="s2">              &amp;&amp; sleep infinity&quot;</span> <span class="p">&amp;</span>
</pre></div>
</div>
<p>One of the advantages of Spark is that it’s resilient: if a worker becomes
unavailable, the computation simply proceeds without it. However, this can
mask issues as well. For example, this example will run perfectly fine with
just one worker, or all four workers on the same node, which aren’t what we
want.</p>
<p>Check the master log to see that the right number of workers registered:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>  fgrep worker /tmp/spark/log/*master*.out
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:39890 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:44735 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:22445 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:29473 with 16 cores, 187.8 GB RAM</span>
</pre></div>
</div>
<p>Despite the workers calling themselves 127.0.0.1, they really are running
across the allocation. (The confusion happens because of our
<code class="code docutils literal notranslate"><span class="pre">$SPARK_LOCAL_IP</span></code> setting above.) This can be verified by examining logs
on each compute node. For example (note single quotes):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh <span class="m">10</span>.8.8.4 -- tail -3 <span class="s1">&#39;/tmp/spark/log/*worker*.out&#39;</span>
<span class="go">17/02/24 22:52:24 INFO Worker: Connecting to master 10.8.8.3:7077...</span>
<span class="go">17/02/24 22:52:24 INFO TransportClientFactory: Successfully created connection to /10.8.8.3:7077 after 263 ms (216 ms spent in bootstraps)</span>
<span class="go">17/02/24 22:52:24 INFO Worker: Successfully registered with master spark://10.8.8.3:7077</span>
</pre></div>
</div>
<p>We can now start an interactive shell to do some Spark computing:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- /spark/bin/pyspark --master <span class="nv">$MASTER_URL</span>
</pre></div>
</div>
<p>Let’s use this shell to estimate 𝜋 (this is adapted from one of the Spark
<a class="reference external" href="http://spark.apache.org/examples.html">examples</a>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>   <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE_CT</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SAMPLE_CT</span><span class="p">))</span> \
<span class="gp">... </span>       <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> \
<span class="gp">... </span>       <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.0</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">SAMPLE_CT</span>
<span class="go">3.14109824</span>
</pre></div>
</div>
<p>(Type Control-D to exit.)</p>
<p>We can also submit jobs to the Spark cluster. This one runs the same example
as included with the Spark source code. (The voluminous logging output is
omitted.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- <span class="se">\</span>
         /spark/bin/spark-submit --master <span class="nv">$MASTER_URL</span> <span class="se">\</span>
         /spark/examples/src/main/python/pi.py <span class="m">1024</span>
<span class="go">[...]</span>
<span class="go">Pi is roughly 3.141211</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Exit your allocation. Slurm will clean up the Spark daemons.</p>
<p>Success! Next, we’ll run a similar job non-interactively.</p>
</section>
<section id="non-interactive-apache-spark">
<h3><a class="toc-backref" href="#id25"><span class="section-number">2.7.4. </span>Non-interactive Apache Spark</a><a class="headerlink" href="#non-interactive-apache-spark" title="Permalink to this headline">¶</a></h3>
<p>We’ll re-use much of the above to run the same computation non-interactively.
For brevity, the Slurm script at <code class="code docutils literal notranslate"><span class="pre">examples/other/spark/slurm.sh</span></code> is not
reproduced here.</p>
<p>Submit it as follows. It requires three arguments: the tarball, the image
directory to unpack into, and the high-speed network interface. Again, consult
your site administrators for the latter.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sbatch -N4 slurm.sh spark.tar.gz /var/tmp ib0
<span class="go">Submitted batch job 86754</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fgrep <span class="s1">&#39;Pi is&#39;</span> slurm-86754.out
<span class="go">Pi is roughly 3.141393</span>
</pre></div>
</div>
<p>Success! (to four significant digits)</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="install.html" class="btn btn-neutral float-left" title="1. Installing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="command-usage.html" class="btn btn-neutral float-right" title="3. Charliecloud command reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014–2022, Triad National Security, LLC and others.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>